# Heroku setup with Node.js

Install the [heroku CLI](https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up)

Login using `heroku login`:

```
$ heroku login
heroku: Press any key to open up the browser to login or q to exit
 ›   Warning: If browser does not open, visit
 ›   https://cli-auth.heroku.com/auth/browser/***
heroku: Waiting for login...
Logging in... done
Logged in as me@example.com
```

## Create an app on Heroku

Create an app on Heroku, which prepares Heroku to receive your source code:

```
$ heroku create
Creating sharp-rain-871... done, stack is heroku-18
http://sharp-rain-871.herokuapp.com/ | https://git.heroku.com/sharp-rain-871.git
Git remote heroku added
```

When you create an app, a git remote (called `heroku`) is also created and associated with your local git repository.

Heroku generates a random name (in this case `sharp-rain-971`) for you app, or you can pass a parameter to specify your own app name.

## Deploy your code:

```
$ git push heroku master
Counting objects: 488, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (367/367), done.
Writing objects: 100% (488/488), 231.85 KiB | 115.92 MiB/s, done.
Total 488 (delta 86), reused 488 (delta 86)
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----> Node.js app detected
remote:
remote: -----> Creating runtime environment
remote:
remote:        NPM_CONFIG_LOGLEVEL=error
remote:        NODE_VERBOSE=false
remote:        NODE_ENV=production
remote:        NODE_MODULES_CACHE=true
remote:
remote: -----> Installing binaries
remote:        engines.node (package.json):  12.x
remote:        engines.npm (package.json):   unspecified (use default)
remote:
remote:        Resolving node version 12.x...
remote:        Downloading and installing node 12.13.0...
remote:        Using default npm version: 6.12.0
       ....
remote: -----> Build succeeded!
remote: -----> Discovering process types
remote:        Procfile declares types -> web
remote:
remote: -----> Compressing...
remote:        Done: 19M
remote: -----> Launching...
remote:        Released v3
remote:        http://sharp-rain-871.herokuapp.com deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/nameless-savannah-4829.git
 * [new branch]      master -> master
```

The application is now deployed. Ensure that at lease one instance of the app is running:

```
$ heroku ps:scale web=1
```

Now visit the app at the URL generated by its app name. As a handy shortcut, you can open the website as follows:

```
$ heroku open
```

## See the logs

```
heroku logs --tail
```

## Define a procfile

The `Procfile` in the example app looks like this:

```
web: node index.js
```

This declares a single process type, `web`, and the command needed to run it. The name `web` is important - it declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.

## Scale the app

See how many dynos are running using the `ps` command:

```
$ heroku ps
=== web (Free): `node index.js`
web.1: up 2014/04/25 16:26:38 (~1s ago)
```

Scaling an app on Heroku is equivalent to changing the number of dynos that are running.

## Declare app dependencies

Heroku recognizes an app as Node.js by the existance of `package.json` in the root directory.

Install all app dependencies:

```
$ npm install
added 132 packages in 3.368s
```

## Run the app locally

```
$ heroku local web
[OKAY] Loaded ENV .env File as KEY=VALUE Format
1:23:15 PM web.1 |  Node app is running on port 5000
```

`heroku local` examimes the `Procfile` to determine what to run.

## Push local changes

Add a dependency for `cool-ascii-faces`:

```
npm install cool-ascii-faces
+ cool-ascii-faces@1.3.4
added 9 packages in 2.027s
```

Make changes to index.js:

```
const cool = require('cool-ascii-faces')
```

Test locally:

```
npm install
heroku local
```

Now deploy:

```
git add .
git commit -m "Add cool face API"
git push heroku master
heroku open cool
```

## Provision add-on

Add-ons are third-party cloud services that provide out-of-the-box services for your application.

By default, Heroku stores 1500 lines of logs from your application. However, it makes the full log stream available as a service - and serveral add-on providers have written logging services that provide things such as persistence, search, email and SMS alerts.

Let's add-on _Papertrail_:

```
heroku addons:create papertrail
Adding papertrail on sharp-rain-871... done, v4 (free)
Welcome to Papertrail. Questions and ideas are welcome (support@papertrailapp.com). Happy logging!
Use `heroku addons:docs papertrail` to view documentation.
```

View all add-ons:

```
heroku addons
```

View the _Papertrail_ console to see the logs:

```
heroku addons:open papertrail
```

## Start a console

To get a real feel for how dynos work, you can create another one-off dyno and run the `bash` command, which opens up a shell on that dyno:

```
$ heroku run bash
Running `bash` attached to terminal... up, run.3052
~ $ ls
Procfile  README.md  composer.json  composer.lock  vendor  views  web
~ $ exit
exit
```

## Define config vars

At runtime, config vars are exposed as environment variables to the application.

To set config vars,

```
$ heroku config:set TIMES=2
```

View the config vars:

```
$ heroku config
== sharp-rain-871 Config Vars
PAPERTRAIL_API_TOKEN: erdKhPeeeehIcdfY7ne
TIMES: 2
```

## Provision a database

Let's add a free Heroku Postgres Starter Tier dev database:

```
$ heroku addons:create heroku-postgresql:hobby-dev
Adding heroku-postgresql:hobby-dev... done, v3 (free)
```

This creates a database, and sets a `DATABASE_URL` environment variable.

### Connect to the Database

```
$ heroku pg:psql
psql (11.5)
SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)
Type "help" for help.
=> create table test_table (id integer, name text);
CREATE TABLE
=> insert into test_table values (1, 'hello database');
INSERT 0 1
=> \q
```

Use `npm` to install the `pg module` to your dependencies:

```
npm install pg
+ pg@7.12.1
added 14 packages in 2.108s
```

Using the environment variable:

```
// index.js
const { Pool } = require('pg');
const pool = new Pool({
       connectionString: process.env.DATABASE_URL,
       ssl: true
});
```

Add a route:

```
.get('/db', async (req, res) => {
       try {
              const client = await pool.connect();
              const result = await client.query('SELECT * FROM test_table');
              const results = {'results': (result) ? results.row : null};
              res.render('pages/db', results);
              client.release();
              client.release();
       } catch (err) {
              console.log(err);
              res.send("Error "+ err);
       }
})
```

This will return all the rows in the `test_table` table.

# Best Practices for Node.js Development

## Start every project with npm init

The first thing you should do is specify an `engines` key with your current version of node (`node -v`):

```
"engines": {
  "node": "12.13.x"
}
```

## Use a smart .npmrc

By default, npm doesn't save installed dependencies to package.json. If you use the `--save` flag to auto-update package.json, npm installs the packages with a leading carat (^), putting your modules at risk of drifting to different versions.

One solution is installing packages like this:

```
$ npm install foobar --save --save-extract
```

Even better, you can set these options in `~/.npmrc` to save your defaults:

```
$ npm config set save=true
$ npm config set save-extract=true
$ cat ~/.npmrc
```

## Stick with lowercase

Some languages encourage filenames that match case names, like `MyClass`. Node.js is the rare example of a Linux-centric tool with great cross-platform support. While OSX and Windows will treat 'myclass.js' and 'MyClass.js' the same, Linux won't.

To write code that's portable between platforms, you'll need to exactly match `require` statements, _including capitalization_.

The easy way to do this is to just stick with lowercase names for everything, eg 'my-class.js'.

## Cluster your app

Since the node runtime is limited to a single core and about 1.5 GB of memory, deploying a non-clustered node app on a large server is a huge waste of resources.

To take advantage of multiple cores and memory beyond 1.5 GB, bake [Cluster support](https://nodejs.org/api/cluster.html) into your app.

Testing is the best way to determine the ideal number of clustered processes for your app, but it's good to start with the [reasonable defaults](https://devcenter.heroku.com/articles/node-concurrency) offered by your platform, with a simple fallback:

```
const CONCURRENCY = process.env.WEB_CONCURRENCY || 1;
```

## Be environmentally aware

Don't litter your project with environment-specific config files! Instead, take advantage of _environment variables_.

To provide a local dev environment, create a .gitignore'd `.env` file, which will be loaded by `heroku_local`:

```
DATABASE_URL="postgres://localhost/foobar"
HTTP_TIMEOUT=10000
```

Now start your app with `heroku local`, and it will automatically pull in these environment variables into your app under `process.env.DATABASE_URL` and `process.env.HTTP_TIMEOUT`.

When you deploy your project, it will automatically adapt to the variables on its new host.

## Avoid garbage

Node (V8) uses a lazy and greedy garbage collector. If your memory usage is increasing, it might not be a leak - but node's lazy behavior.

To gain more control over your app's garbage collector, you can provide flags to V8 in your `Procfile`:

```
web: node --optimize_for_size --max_old_space_size=920 --gc_internal=100 server.js
```

This is especially important if your app is running in an environment with less thatn 1.5GB of available memory. For example, if you'd like to tailor node to a 512 MB container, try:

```
web: node --optimize_for_size --max_old_space_size=460 --gc_internal=100 server.js
```

## Hook things up

Npm's [lifecycle scripts](https://docs.npmjs.com/misc/scripts) make great hooks for automation.

Heroku provides custom hooks that allow you to run custom commands before or after we install your dependencies. If you need to run something before building your app, you can use the `heroku-rebuild` script. Need to build assets with grunt, gulp, browserify, or webpack? Do it in a `build` script.

In package.json:

```
"scripts": {
  "build": "bower install && grunt build",
  "start": "nf start"
}
```

You can also use environment variables to control these scripts:

```
"build": "if [ $BUILD_ASSETS ]; then npm run build-assets; fi",
"build-assets": "bower install && grunt build"
```

If your scripts are getting out of hand, move them to files:

```
"build": "scripts/build.sh"
```

Scripts in package.json automaticall have `./node_modules/.bin` added to their `PATH`, so you can execute binaries like `bower` or `webpack` directly.

## Only git the important bits

Don't include `node_modules` or `bower_components` or any generated files.

By ignoring these unnecessary files, your repositories will be smaller, your commits will be simpler, and you'll avoid merge conficts in the generated directories.
